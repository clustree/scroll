{"version":3,"sources":["../../src/rafobserver.tsx","../../src/index.tsx","App.js","serviceWorker.js","index.js"],"names":["af","observers","Set","rafloop","time","fifoqueue","obs","Array","from","push","measure","cb","shift","requestAnimationFrame","ScrollY","dark","children","useState","scrollbarWidth","setScrollbarWidth","rootRef","useRef","scrollContainerRef","scrollbarRef","useEffect","observer","state","_isDraggingScrollbar","_initialScrollTop","_initialScrollbarY","_scrollbarScale","_offset","_timeout","prevValues","dataset","current","scrollContainer","scrollbar","unobserve","add","scrollTop","scrollHeight","offsetHeight","newValues","some","val","i","clearTimeout","setTimeout","scrolling","offset","scale","style","transform","hidden","size","cancelAnimationFrame","mouseDown","event","preventDefault","clientY","moving","mouseUp","mouseMove","addEventListener","removeEventListener","useLayoutEffect","offsetWidth","clientWidth","React.createElement","className","ref","right","paddingRight","LoremIpsum","count","fill","map","l","key","NativeScroll","App","defaultValue","isDark","toggleDark","document","documentElement","classList","remove","v","useDarkMode","useNativeScroll","toggleNativeScroll","dropdownOpen","toggleDropDown","setCount","Component","type","onClick","min","max","value","onChange","e","Number","parseInt","target","Boolean","window","location","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.b3659b56.chunk.js","sourcesContent":["type Observer<T> = [() => T, (value: T, time: number) => void];\n\nconst observers = new Set<Observer<any>>();\n\nlet af;\n\nfunction rafloop(time: number) {\n  // fifoqueue\n  const fifoqueue = [];\n\n  // This line ensure no new observers are added during the loop.\n  // It also helps microbundle shrink the output\n  const obs = Array.from(observers);\n\n  // Measure first\n  for (const [measure] of obs) {\n    fifoqueue.push(measure());\n  }\n  // Run callbacks from measure\n  for (const [, cb] of obs) {\n    cb(fifoqueue.shift(), time);\n  }\n\n  af = requestAnimationFrame(rafloop);\n}\n\nexport function observe<T>(measure: Observer<T>[0], cb: Observer<T>[1]) {\n  const observer: Observer<T> = [measure, cb];\n  // If we are adding the first observer\n  observers.add(observer);\n  if (observers.size === 1) {\n    // Start the requestAnimationFrame measure callback loop\n    af = requestAnimationFrame(rafloop);\n  }\n  return () => {\n    observers.delete(observer);\n    if (!observers.size) {\n      cancelAnimationFrame(af);\n    }\n  };\n}\n","import './index.scss';\nimport * as React from 'react';\nimport type { ReactNode } from 'react';\nimport { useState, useLayoutEffect, useEffect, useRef } from 'react';\nimport { observe } from './rafobserver';\n\nconst GUTTER_WIDTH = 40;\n\nexport function ScrollY({ dark, children }: { dark?: boolean; children: ReactNode }) {\n  const [scrollbarWidth, setScrollbarWidth] = useState(0);\n\n  // We store a reference to the top level node to set data attributes\n  // We use these data attributes to style the scrollbar\n  // - scrolling: the element is scrolling (with a 100ms timeout using scrollingTimeout)\n  // - hidden: the element has no scrollbar\n  // - moving: the element is being dragged\n  const rootRef = useRef<HTMLDivElement>(null);\n\n  // This stores a reference to the inner div that we measure\n  const scrollContainerRef = useRef<HTMLDivElement>(null);\n\n  // This stores a reference to the scrollbar itself\n  const scrollbarRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    const state = {\n      // Are we currently dragging the scrollbar\n      _isDraggingScrollbar: false,\n      // Initial scrollTop when we started dragging\n      _initialScrollTop: -1,\n      // Initial scrollbar position\n      _initialScrollbarY: -1,\n      _scrollbarScale: 1,\n      _offset: -1,\n      _timeout: null,\n    };\n    // Previously measured values\n    let prevValues = [];\n\n    const { dataset } = rootRef.current;\n    const scrollContainer = scrollContainerRef.current;\n    const scrollbar = scrollbarRef.current;\n\n    // measure every frame\n    // This is the only reliable way to check for scrollHeight changes\n    const unobserve = observe(\n      () => {\n        // console.log('measure called');\n        return [scrollContainer.scrollTop, scrollContainer.scrollHeight, scrollContainer.offsetHeight];\n      },\n      (newValues, time) => {\n        // Check if any value has changed\n        if (newValues.some((val, i) => val !== prevValues[i])) {\n          clearTimeout(state._timeout);\n          state._timeout = setTimeout(() => {\n            delete dataset.scrolling;\n          }, 100);\n          dataset.scrolling = 'true';\n          prevValues = newValues;\n        }\n        const [scrollTop, scrollHeight, offsetHeight] = newValues;\n\n        const offset = (100 * scrollTop) / scrollHeight;\n        const scale = offsetHeight / scrollHeight;\n\n        if (state._scrollbarScale !== scale || offset != state._offset) {\n          // Move the scrollbar\n          scrollbar.style.transform = `translateY(${offset}%) scaleY(${scale})`;\n          if (scale != state._scrollbarScale) {\n            // If scale has changed, we need to redraw the rounded corners of the bar\n            for (const child of Array.from(scrollbar.children)) {\n              (child as HTMLElement).style.transform = `scaleY(${1 / scale})`;\n            }\n            // Show or hide the scrollbar depending on scale\n            if (scale < 1) {\n              delete dataset.hidden;\n            } else {\n              dataset.hidden = 'true';\n            }\n            state._scrollbarScale = scale;\n          }\n        }\n      },\n    );\n\n    const mouseDown = (event: MouseEvent) => {\n      // Prevent click events from bubbling up and closing modals for instance\n      event.preventDefault();\n      state._isDraggingScrollbar = true;\n      state._initialScrollbarY = event.clientY;\n      state._initialScrollTop = scrollContainer.scrollTop;\n\n      dataset.moving = 'true';\n    };\n\n    const mouseUp = () => {\n      if (!state._isDraggingScrollbar) {\n        return;\n      }\n      state._isDraggingScrollbar = false;\n      delete dataset.moving;\n    };\n\n    const mouseMove = (event: MouseEvent) => {\n      if (!state._isDraggingScrollbar) {\n        return;\n      }\n      const diff = (event.clientY - state._initialScrollbarY) / state._scrollbarScale;\n      scrollContainer.scrollTop = state._initialScrollTop + diff;\n    };\n\n    addEventListener('mouseup', mouseUp);\n    addEventListener('mousemove', mouseMove);\n    scrollbar.addEventListener('mousedown', mouseDown);\n    return () => {\n      // Cancel the animationLoop\n      unobserve();\n      removeEventListener('mouseup', mouseUp);\n      removeEventListener('mousemove', mouseMove);\n      scrollbar.removeEventListener('mousedown', mouseDown);\n    };\n  }, []);\n\n  useLayoutEffect(() => {\n    const { offsetWidth, clientWidth } = scrollContainerRef.current;\n\n    const width = offsetWidth - clientWidth;\n    setScrollbarWidth(width);\n  }, []);\n\n  return (\n    <div className={`scroll-y ${dark ? 'dark' : ''}`} ref={rootRef}>\n      <div\n        ref={scrollContainerRef}\n        className=\"scroll-y__scrollbar-hider\"\n        style={{\n          // Hide scrollbar outside of viewport\n          right: -GUTTER_WIDTH,\n          paddingRight: GUTTER_WIDTH - scrollbarWidth,\n        }}\n      >\n        {children}\n      </div>\n      <div className=\"scroll-y__scrollbar-container\">\n        <div ref={scrollbarRef} className=\"scroll-y__scrollbar\">\n          <div />\n          <div />\n        </div>\n      </div>\n    </div>\n  );\n}\n","import '@clustree/scroll/lib/index.css';\nimport './App.css';\n\nimport React, { useState, useLayoutEffect } from 'react';\nimport { ScrollY } from '@clustree/scroll';\nimport { Number } from 'core-js';\n\nfunction useDarkMode(defaultValue = false) {\n  const [isDark, toggleDark] = useState(defaultValue);\n\n  useLayoutEffect(() => {\n    if (isDark) {\n      document.documentElement.classList.add('dark');\n    } else {\n      document.documentElement.classList.remove('dark');\n    }\n  }, [isDark]);\n\n  return [isDark, () => toggleDark(v => !v)];\n}\n\nconst LOREM = `Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.`;\n\nfunction LoremIpsum({ count }) {\n  return (\n    <>\n      {new Array(count).fill(LOREM).map((l, i) => (\n        <p key={i}>{l}</p>\n      ))}\n    </>\n  );\n}\n\nfunction NativeScroll({ children }) {\n  return <div className=\"nativeScroll\">{children}</div>;\n}\n\nfunction App() {\n  const [isDark, toggleDark] = useDarkMode(true);\n  const [useNativeScroll, toggleNativeScroll] = useState(false);\n  const [dropdownOpen, toggleDropDown] = useState(false);\n  const [count, setCount] = useState(5);\n\n  const Component = useNativeScroll ? NativeScroll : ScrollY;\n  return (\n    <div className=\"App\">\n      <h1>@clustree/scroll</h1>\n\n      <div className=\"main\">\n        <div>\n          <p>\n            <code>{'<ScrollY />'}</code> is a custom scrollbar with a transparent track.\n          </p>\n          <p>\n            It takes one boolean prop: <code>dark</code> that determines if the scrollbar thumb is dark or light.\n          </p>\n          <p>\n            This allows one to have consistent scrollbar styling across many browsers and OSes, including Internet\n            Explorer 11.\n          </p>\n          <button type=\"button\" onClick={toggleDark}>\n            Toggle Dark mode\n          </button>\n        </div>\n        <div>\n          <h3>Demo:</h3>\n          <h4>\n            {useNativeScroll ? 'Using native scrollbars' : 'Using <ScrollY />'}{' '}\n            <button type=\"button\" onClick={() => toggleNativeScroll(v => !v)}>\n              {!useNativeScroll ? 'Use native scrollbars' : 'Use <ScrollY />'}{' '}\n            </button>\n          </h4>\n\n          <label>\n            Number of paragraphs:{` `}\n            <input\n              type=\"range\"\n              min=\"1\"\n              max=\"10\"\n              value={count}\n              onChange={e => setCount(Number.parseInt(e.target.value, 10))}\n            />\n            {` ${count}`}\n          </label>\n\n          <div className=\"demo\">\n            <Component dark={!isDark}>\n              <div className=\"inner\">\n                <LoremIpsum count={count} />\n                <div className=\"relative\">\n                  <button onClick={() => toggleDropDown(v => !v)}>Toggle absolutely positionned content</button>\n                  {dropdownOpen ? (\n                    <div className=\"absolute\">\n                      Absolute content that overflows affects total height for the scrollbar\n                    </div>\n                  ) : null}\n                </div>\n              </div>\n            </Component>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}